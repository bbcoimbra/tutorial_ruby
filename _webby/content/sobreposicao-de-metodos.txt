---
title:      Sobreposicao de Metodos
created_at: 2009-12-23 14:29:25.387994 -02:00
filter:
 - erb
 - textile
---
p(title). <%= h(@page.title) %>

Method overriding, in object oriented programming, is a language feature that allows a subclass to provide a specific implementation of a method that is already provided by one of its superclasses. The implementation in the subclass overrides (replaces) the implementation in the superclass.

Here's an example p037xmtdovride.rb:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
  class A
    def a
      puts 'In class A'
    end
  end

  class B < A
    def a
      puts 'In class B'
    end
  end

  b = B.new
  b.a
<% end -%>

The method a in class B overrides the method a in class A.


h2. Usage of super

The way super handles arguments is as follows:

* When you invoke super with no arguments Ruby sends a message to the parent of the current object, asking it to invoke a method of the same name as the method invoking super. It automatically forwards the arguments that were passed to the method from which it's called.
* Called with an empty argument list - super()-it sends no arguments to the higher-up method, even if arguments were passed to the current method.
* Called with specific arguments - super(a, b, c) - it sends exactly those arguments.


An example (p038bicycle.rb) from Ruby for Rails book highlights this:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
  class Bicycle
    attr_reader :gears, :wheels, :seats
    def initialize(gears = 1)
      @wheels = 2
      @seats = 1
      @gears = gears
    end
  end

  class Tandem < Bicycle
    def initialize(gears)
      super
      @seats = 2
    end
  end
  t = Tandem.new(2)
  puts t.gears
  puts t.wheels
  puts t.seats
  b = Bicycle.new
  puts b.gears
  puts b.wheels
  puts b.seats
<% end -%>


The output is:

<% coderay(:lang => "bash", :line_numbers => "inline") do -%>
  >ruby p038bicycle.rb
  2
  2
  2
  1
  2
  1
  >Exit code: 0
<% end -%>


We shall be talking in depth about attr_reader later.


h2. Redefining Methods

(Adapted from David Black's book, Ruby For Rails)

Nothing stops you from defining a method twice. Program p038or.rb

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
  class OR
    def mtd
      puts "First definition of method mtd"
    end
    def mtd
      puts "Second definition of method mtd"
    end
  end
  OR.new.mtd
<% end -%>


What happens when we call mtd on an instance of OR? Let's find out:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
  OR.new.mtd
<% end -%>


The printed result is the Second definition of method mtd. The second definition has prevailed: We see the output from that definition, not from the first. Nothing stops you from defining a method twice, however the new version takes precedence.


h2. Abstract class

In Ruby, we can define an abstract class that invokes certain undefined "abstract" methods, which are left for subclasses to define. For example:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
  # This class is abstract; it doesn't define hello or name
  # No special syntax is required: any class that invokes methods
  # that are intended for a subclass to implement is abstract
  class AbstractKlass
    def welcome
      puts "#{hello} #{name}"
    end
  end

  # A concrete class
  class ConcreteKlass < AbstractKlass
    def hello; "Hello"; end
    def name; "Ruby students"; end
  end

  ConcreteKlass.new.welcome # Displays "Hello Ruby students"
<% end -%>
